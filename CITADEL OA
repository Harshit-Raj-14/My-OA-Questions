A data processing pipeline consists of n services connected in a series where the output of the ith service serves as the input to the (i+ 1)th service. However, the processing units have varying latencies, and the throughput of the ith unit is represented by the array throughput[i] in messages per minute. The first service receives input through an API, and the nth service produces the final output.

Each service can be scaled up independently, with the cost of scaling up the ith service one unit equal to scaling_ cost[i]. After scaling up a service x times, it can process throughput[i]*(1 + x) messages per minute.

Given the arrays throughput and scaling_ cost, both of size n, and an integer budget representing the budget available, determine the optimal scaling configuration for the services such that the throughput generated by the nth service is maximized.

For instance, throughput = [4, 2, 7], scaling_cost = [3, 5, 6], and budget = 32.
To maximize the throughput of the final service, an optimal solution is:

Service index 	scale from 	scale to 	Times scaled 	cost per scaling 	total cost
0 	4 	12 	2 	3 	6
1 	2 	10 	4 	5 	20
2 	7 	14 	1 	6 	6

When these units are applied in series they generate a throughput of 10 units, the maximum possible throughput given the budget, hence the answer is 10


public class OptimalScaling {

    public static void main(String[] args) {
        int[] throughput = {4, 2, 7};
        int[] scalingCost = {3, 5, 6};
        int budget = 32;

        int maxThroughput = maximizeThroughput(throughput, scalingCost, budget);
        System.out.println("Maximum Throughput: " + maxThroughput);
    }

    public static int maximizeThroughput(int[] throughput, int[] scalingCost, int budget) {
        int left = 0, right = Integer.MAX_VALUE, maxThroughput = 0;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (canAchieveThroughput(throughput, scalingCost, budget, mid)) {
                maxThroughput = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return maxThroughput;
    }

    public static boolean canAchieveThroughput(int[] throughput, int[] scalingCost, int budget, int targetThroughput) {
        int totalCost = 0;

        for (int i = 0; i < throughput.length; i++) {
            if (throughput[i] >= targetThroughput) {
                continue;
            }

            int requiredScaling = (targetThroughput - throughput[i] + throughput[i] - 1) / throughput[i]; // ceil((targetThroughput - throughput[i]) / throughput[i])
            totalCost += requiredScaling * scalingCost[i];

            if (totalCost > budget) {
                return false;
            }
        }

        return totalCost <= budget;
    }
}
