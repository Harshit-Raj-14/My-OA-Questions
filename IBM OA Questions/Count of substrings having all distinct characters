/*TWO POINTER O(n) */
public static int solution(String s) {
    int n = s.length();
    int ans = 0;
    int count[] = new int[26];
    int i = 0;
    int j = 0;
    while (i < s.length()) {
        if (j < s.length() && count[s.charAt(j) - 'a'] == 0) {
            count[s.charAt(j) - 'a']++;
            ans += (j - i + 1);
            j++;
        } else {
            count[s.charAt(i) - 'a']--;
            i++;
        }
    }
    return ans;
}

LOGIC---
Consider two pointers i and j, initially both pointing to the first character of the string i.e. i = j = 0.

Initialize an array count[26] to store the count of characters in substring from index i to j both inclusive.

Now, keep on incrementing j pointer until some a repeated character is encountered. While incrementing j, 
add the count of all the substrings ending at jth index and starting at any index between i and j to the answer.
 
All these substrings will contain distinct characters as no character is repeated in them.
If some repeated character is encountered in substring between index i to j, to exclude this repeated character, 
keep on incrementing the i pointer until repeated character is removed and keep updating Cnt[ ] array accordingly.

Continue this process until j reaches the end of string. Once the string is traversed completely, print the answer.



VARIATIONS OF THIS QUESTION---
Count number of substring having exactly k distinct characters
Count number of substring having atmost k distinct characters


/* BRUTE FORCE O(n^3) */
public static int distinctCharSubString(String s) {
    int ans = 0;
    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            String t = s.substring(i, j + 1);
            int count[] = new int[26];
            for (int k = 0; k < t.length(); k++) {
                count[t.charAt(k) - 'a']++;
            }
            int isPossible = 1;
            for (int p = 0; p < 26; p++) {
                if (count[p] > 1) isPossible = 0;
            }
            if (isPossible == 1) ans++;
        }
    }
    return ans;
}


LOGIC---
Find all substrings and then check which substring have unique characters using a frequency table.
Aoso, note this answer may have repeated type of substrings with unique characters.
So, in case unqiue substrings are aksed make an adidtion hashset for already once counted substring.

